import React, { useState, useCallback, useRef, useMemo, useEffect } from 'react';
import {
  Typography,
  Box,
  Chip,
  Divider,
  CircularProgress,
  Pagination,
  TextField,
  Button,
  Tooltip,
  IconButton
} from '@mui/material';
import { 
  MenuBook as DictionaryIcon,
  NavigateBefore as PrevPageIcon,
  NavigateNext as NextPageIcon,
  KeyboardArrowUp as UpIcon,
  KeyboardArrowDown as DownIcon
} from '@mui/icons-material';
import { Book, WordTranslation, SelectedWord, UserDictionaryWord, TextComment } from '../types';

import translationService from '../services/translationService';
import UserDictionary from './UserDictionary';
import AddCommentModal from './AddCommentModal';
import CommentsPanel from './CommentsPanel';
import NavigationPanel, { FormattingOptions } from './NavigationPanel';
import TranslationTooltip from './TranslationTooltip';

interface TextReaderProps {
  book: Book;
  isDictionaryOpen?: boolean;
  onDictionaryToggle?: () => void;
  isCommentsPanelOpen?: boolean;
  onCommentsPanelToggle?: () => void;
}

const TextReader: React.FC<TextReaderProps> = ({ 
  book, 
  isDictionaryOpen: externalIsDictionaryOpen, 
  onDictionaryToggle,
  isCommentsPanelOpen: externalIsCommentsPanelOpen,
  onCommentsPanelToggle
}) => {
  const [selectedWord, setSelectedWord] = useState<SelectedWord | null>(null);
  const [translation, setTranslation] = useState<WordTranslation | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [currentPage, setCurrentPage] = useState(() => {
    // Восстанавливаем последнюю страницу из localStorage или используем 1
    const savedPage = localStorage.getItem(`book-last-page-${book.id}`);
    return savedPage ? parseInt(savedPage, 10) : 1;
  });
  const [goToPage, setGoToPage] = useState('');
  const [internalIsDictionaryOpen, setInternalIsDictionaryOpen] = useState(false);
  const [userDictionary, setUserDictionary] = useState<UserDictionaryWord[]>([]);
  const [showOnlyCurrentPageWords, setShowOnlyCurrentPageWords] = useState(false);

  const [comments, setComments] = useState<TextComment[]>([]);
  const [internalIsCommentsPanelOpen, setInternalIsCommentsPanelOpen] = useState(false);

  const [isAddCommentModalOpen, setIsAddCommentModalOpen] = useState(false);
  const [selectedTextForComment, setSelectedTextForComment] = useState('');
  const [showOnlyCurrentPageComments, setShowOnlyCurrentPageComments] = useState(true);
  const [highlightedComments, setHighlightedComments] = useState<TextComment[]>([]);
  const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>(() => {
    return {
      fontSize: 16,
      fontFamily: 'Fira Sans, sans-serif',
      containerHeight: 85
    };
  });
  const [containerWidth, setContainerWidth] = useState(() => {
    const saved = localStorage.getItem('container-width');
    return saved ? parseInt(saved, 10) : 800;
  }); // Ширина контейнера в пикселях
  const [containerHeight, setContainerHeight] = useState(() => {
    // Принудительно устанавливаем высоту 1000px
    localStorage.setItem('container-height', '1000');
    return 1000;
  }); // Высота контейнера в пикселях
  const [isResizing, setIsResizing] = useState(false);
  const [resizeStartX, setResizeStartX] = useState(0);
  const [resizeStartY, setResizeStartY] = useState(0);
  const [resizeStartWidth, setResizeStartWidth] = useState(0);
  const [resizeStartHeight, setResizeStartHeight] = useState(0);

  // Функции для изменения ширины перетаскиванием
  const handleResizeStart = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    
    // Устанавливаем состояние перетаскивания
    setIsResizing(true);
    setResizeStartX(e.clientX);
    setResizeStartY(e.clientY);
    setResizeStartWidth(containerWidth);
    setResizeStartHeight(containerRef.current?.offsetHeight || 0);
    
    // Изменяем курсор и предотвращаем выделение
    document.body.style.cursor = 'nw-resize';
    document.body.style.userSelect = 'none';
  }, [containerWidth]);

  const handleResizeMove = useCallback((e: MouseEvent) => {
    if (!isResizing) return;
    
    const deltaX = e.clientX - resizeStartX;
    const deltaY = e.clientY - resizeStartY;
    
    // Определяем максимальную ширину на основе размера шрифта и длины строки
    const fontSize = formattingOptions.fontSize;
    const averageCharWidth = fontSize * 0.6; // Примерная ширина символа
    const maxCharsPerLine = 80; // Максимальное количество символов в строке для комфортного чтения
    
    const maxTextWidth = maxCharsPerLine * averageCharWidth;
    const maxAllowedWidth = Math.min(window.innerWidth - 200, maxTextWidth + 40); // Максимальная ширина
    const maxAllowedHeight = Math.max(1000, window.innerHeight - 200); // Максимальная высота (минимум 1000px)
    
    // Изменяем размер при перетаскивании (увеличиваем или уменьшаем)
    const newWidth = Math.max(150, Math.min(maxAllowedWidth, resizeStartWidth + deltaX));
    const newHeight = Math.max(150, Math.min(maxAllowedHeight, resizeStartHeight + deltaY));
    
    setContainerWidth(newWidth);
    setContainerHeight(newHeight);
    
    // Обновляем стили контейнера напрямую
    if (containerRef.current) {
      containerRef.current.style.width = `${newWidth}px`;
      containerRef.current.style.maxWidth = `${newWidth}px`;
      containerRef.current.style.height = `${newHeight}px`;
      containerRef.current.style.maxHeight = `${newHeight}px`;
      containerRef.current.style.flex = 'none';
    }
    
    // Обновляем стили обертки
    const wrapperElement = containerRef.current?.parentElement;
    if (wrapperElement) {
      wrapperElement.style.width = `${newWidth}px`;
      wrapperElement.style.height = `${newHeight}px`;
    }
  }, [isResizing, resizeStartX, resizeStartY, resizeStartWidth, resizeStartHeight, formattingOptions.fontSize]);

  const handleResizeEnd = useCallback(() => {
    if (isResizing) {
      setIsResizing(false);
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      localStorage.setItem('container-width', containerWidth.toString());
      localStorage.setItem('container-height', containerHeight.toString());
      
      // Сохраняем состояние flex
      if (containerRef.current) {
        containerRef.current.style.flex = 'none';
      }
    }
  }, [isResizing, containerWidth]);

  // Используем внешнее состояние, если оно передано, иначе внутреннее
  const isDictionaryOpen = externalIsDictionaryOpen !== undefined ? externalIsDictionaryOpen : internalIsDictionaryOpen;
  const setIsDictionaryOpen = externalIsDictionaryOpen !== undefined ? 
    (onDictionaryToggle || (() => {})) : 
    setInternalIsDictionaryOpen;



  const isCommentsPanelOpen = externalIsCommentsPanelOpen !== undefined ? externalIsCommentsPanelOpen : internalIsCommentsPanelOpen;
  const setIsCommentsPanelOpen = externalIsCommentsPanelOpen !== undefined ? 
    (onCommentsPanelToggle || (() => {})) : 
    setInternalIsCommentsPanelOpen;



  const containerRef = useRef<HTMLDivElement>(null);
  const selectedWordRef = useRef<SelectedWord | null>(null);

  // Функция для расчета позиции тултипа
  const getTooltipStyle = useCallback((element: HTMLElement) => {
    const rect = element.getBoundingClientRect();
    
    // Фиксированные размеры
    const leftPanelWidth = 80; // Ширина левой боковой панели
    const marginLeft = 80; // Отступ от левого края (как в стилях контейнера)
    
    // Рассчитываем позицию тултипа между панелью и контейнером
    const left = leftPanelWidth + 10; // 10px отступ от левой панели
    const availableWidth = 800 - leftPanelWidth - 20; // 800px - ширина контейнера, 20px для отступов
    const tooltipWidth = availableWidth - 4; // Ширина на 4px меньше доступного пространства
    
    // Позиционируем тултип на уровне выделенного слова
    const top = rect.top;

    return {
      position: 'fixed' as const,
      left: left,
      top: top,
      zIndex: 1000,
      width: tooltipWidth,
      minHeight: 80
    };
  }, []);

  // Функция для очистки слова от знаков препинания
  const cleanWord = useCallback((word: string) => {
    return word.replace(/[.,!?;:()"'`]/g, '').toLowerCase().trim();
  }, []);

  // Функция для выделения слова в тексте
  const highlightWord = useCallback((element: HTMLElement, word: string) => {
    const text = element.textContent || '';
    const words = text.split(/\s+/);
    let highlightedText = '';
    let currentIndex = 0;
    
    words.forEach((w, index) => {
      const cleanedW = cleanWord(w);
      const cleanedTarget = cleanWord(word);
      
      if (cleanedW === cleanedTarget) {
        // Выделяем слово синим цветом
        highlightedText += `<span style="background-color: #1976d2; color: white; padding: 1px 2px; border-radius: 2px;">${w}</span>`;
      } else {
        highlightedText += w;
      }
      
      // Добавляем пробел между словами (кроме последнего)
      if (index < words.length - 1) {
        highlightedText += ' ';
      }
    });
    
    return highlightedText;
  }, [cleanWord]);

  // Обработчик одного клика по слову для перевода
  const handleWordClick = useCallback(async (event: React.MouseEvent<HTMLParagraphElement>) => {
    event.preventDefault();
    event.stopPropagation();
    
    // Получаем выделенный текст
    const selection = window.getSelection();
    const selectedText = selection?.toString().trim();
    
    // Если есть выделение, не обрабатываем клик (это будет обработано handleMouseUp)
    if (selectedText && selectedText.length > 0) {
      return;
    }
    
    // Получаем слово под курсором
    const text = event.currentTarget.textContent || '';
    const clickX = event.clientX - event.currentTarget.getBoundingClientRect().left;
    
    // Находим слово по позиции клика
    const words = text.split(/\s+/);
    let currentX = 0;
    let clickedWord = '';
    
    for (const word of words) {
      const wordWidth = word.length * 8; // Примерная ширина
      if (currentX <= clickX && clickX <= currentX + wordWidth) {
        clickedWord = word;
        break;
      }
      currentX += wordWidth + 8; // +8 для пробела
    }
    
    if (!clickedWord || clickedWord.length < 2) return;
    
    const cleanedWord = cleanWord(clickedWord);
    if (cleanedWord.length < 2) return;

    // Выделяем слово в тексте
    const highlightedText = highlightWord(event.currentTarget, clickedWord);
    event.currentTarget.innerHTML = highlightedText;

    const selectedWordData: SelectedWord = {
      word: cleanedWord,
      originalWord: clickedWord,
      element: event.currentTarget
    };

    setSelectedWord(selectedWordData);
    selectedWordRef.current = selectedWordData;

    setIsLoading(true);

    try {
      const translationData = await translationService.translateWord(cleanedWord);
      setTranslation(translationData);
    } catch (error) {
      console.error('Ошибка при переводе слова:', error);
      setTranslation(null);
    } finally {
      setIsLoading(false);
    }
  }, [cleanWord, highlightWord]);



  // Обработчик двойного клика для добавления в словарь
  const handleDoubleClick = useCallback(async (event: React.MouseEvent<HTMLParagraphElement>) => {
    event.preventDefault();
    event.stopPropagation();
    
    // Получаем выделенный текст
    const selection = window.getSelection();
    const selectedText = selection?.toString().trim();
    
    // Если есть выделение, не обрабатываем двойной клик (это будет обработано handleMouseUp)
    if (selectedText && selectedText.length > 0) {
      return;
    }
    
    // Получаем слово под курсором
    const text = event.currentTarget.textContent || '';
    const clickX = event.clientX - event.currentTarget.getBoundingClientRect().left;
    
    // Находим слово по позиции клика
    const words = text.split(/\s+/);
    let currentX = 0;
    let clickedWord = '';
    
    for (const word of words) {
      const wordWidth = word.length * 8; // Примерная ширина
      if (currentX <= clickX && clickX <= currentX + wordWidth) {
        clickedWord = word;
        break;
      }
      currentX += wordWidth + 8; // +8 для пробела
    }
    
    if (!clickedWord || clickedWord.length < 2) return;
    
    const cleanedWord = cleanWord(clickedWord);
    if (cleanedWord.length < 2) return;

    // Выделяем слово в тексте
    const highlightedText = highlightWord(event.currentTarget, clickedWord);
    event.currentTarget.innerHTML = highlightedText;

    // Если уже есть перевод для этого слова, добавляем в словарь
    if (translation && selectedWord && selectedWord.word === cleanedWord) {
      // Добавляем в словарь напрямую
      const newWord: UserDictionaryWord = {
        id: Date.now().toString(),
        word: selectedWord.word,
        originalWord: selectedWord.originalWord,
        translation: translation,
        position: 0,
        bookId: book.id,
        pageNumber: currentPage,
        lastEdited: new Date().toISOString()
      };

      const updatedDictionary = [...userDictionary, newWord];
      setUserDictionary(updatedDictionary);
      
      try {
        localStorage.setItem('userDictionary', JSON.stringify(updatedDictionary));
        console.log('Слово добавлено в словарь:', selectedWord.word);
      } catch (error) {
        console.error('Ошибка при сохранении словаря:', error);
      }

      setSelectedWord(null);
      setTranslation(null);
    } else {
      // Если нет перевода, сначала получаем его
      const selectedWordData: SelectedWord = {
        word: cleanedWord,
        originalWord: clickedWord,
        element: event.currentTarget
      };

      setSelectedWord(selectedWordData);
      selectedWordRef.current = selectedWordData;

      setIsLoading(true);

      try {
        const translationData = await translationService.translateWord(cleanedWord);
        setTranslation(translationData);
        
        // Добавляем в словарь после получения перевода
        setTimeout(() => {
          const newWord: UserDictionaryWord = {
            id: Date.now().toString(),
            word: selectedWordData.word,
            originalWord: selectedWordData.originalWord,
            translation: translationData,
            position: 0,
            bookId: book.id,
            pageNumber: currentPage,
            lastEdited: new Date().toISOString()
          };

          const updatedDictionary = [...userDictionary, newWord];
          setUserDictionary(updatedDictionary);
          
          try {
            localStorage.setItem('userDictionary', JSON.stringify(updatedDictionary));
            console.log('Слово добавлено в словарь:', selectedWordData.word);
          } catch (error) {
            console.error('Ошибка при сохранении словаря:', error);
          }

          setSelectedWord(null);
          setTranslation(null);
        }, 100);
      } catch (error) {
        console.error('Ошибка при переводе слова:', error);
        setTranslation(null);
      } finally {
        setIsLoading(false);
      }
    }
  }, [cleanWord, highlightWord, translation, selectedWord, userDictionary, book.id, currentPage]);

  // Обработчик клика вне слова
  const handleClickOutside = useCallback((event: MouseEvent) => {
    // Проверяем, что клик не по элементу с текстом или тултипу
    const target = event.target as HTMLElement;
    if (target.closest('.text-content-container') || 
        target.closest('.MuiPaper-root') || 
        target.closest('[data-testid="translation-tooltip"]')) {
      return;
    }
    
    if (selectedWordRef.current) {
      // Снимаем выделение с предыдущего слова
      if (selectedWordRef.current.element) {
        const originalText = selectedWordRef.current.element.textContent || '';
        selectedWordRef.current.element.innerHTML = originalText;
      }
      
      setSelectedWord(null);
      setTranslation(null);
      selectedWordRef.current = null;
    }
  }, []);

  // Обработчик добавления слова в словарь
  const handleAddToDictionary = useCallback(() => {
    if (!selectedWord || !translation) return;

    const newWord: UserDictionaryWord = {
      id: Date.now().toString(),
      word: selectedWord.word,
      originalWord: selectedWord.originalWord,
      translation: translation,
      position: 0,
      bookId: book.id,
      pageNumber: currentPage,
      lastEdited: new Date().toISOString()
    };

    const updatedDictionary = [...userDictionary, newWord];
    setUserDictionary(updatedDictionary);
    
    try {
      localStorage.setItem('userDictionary', JSON.stringify(updatedDictionary));
      console.log('Слово добавлено в словарь:', selectedWord.word);
    } catch (error) {
      console.error('Ошибка при сохранении словаря:', error);
    }

    setSelectedWord(null);
    setTranslation(null);
  }, [selectedWord, translation, currentPage, userDictionary, book.id]);

  // Обработчик удаления из словаря
  const handleDeleteFromDictionary = useCallback((wordId: string) => {
    const wordToDelete = userDictionary.find(w => w.id === wordId);
    if (!wordToDelete) return;

    const confirmDelete = window.confirm(
      `Удалить слово "${wordToDelete.originalWord}" со всеми переводами?\n\nПереводы:\n${wordToDelete.translation.meanings.map(m => `• ${m}`).join('\n')}`
    );

    if (confirmDelete) {
      const updatedDictionary = userDictionary.filter(w => w.id !== wordId);
      setUserDictionary(updatedDictionary);
      
      try {
        localStorage.setItem('userDictionary', JSON.stringify(updatedDictionary));
        console.log('Слово удалено из словаря:', wordToDelete.word);
      } catch (error) {
        console.error('Ошибка при сохранении словаря:', error);
      }
    }
  }, [userDictionary]);

  // Обработчик изменения страницы
  const handlePageChange = useCallback((page: number) => {
    // Снимаем выделение с предыдущего слова при смене страницы
    if (selectedWordRef.current && selectedWordRef.current.element) {
      const originalText = selectedWordRef.current.element.textContent || '';
      selectedWordRef.current.element.innerHTML = originalText;
    }
    
    setSelectedWord(null);
    setTranslation(null);
    selectedWordRef.current = null;
    setCurrentPage(page);
  }, []);

  // Обработчик перехода на конкретную страницу
  const handleGoToPage = useCallback(() => {
    const page = parseInt(goToPage, 10);
    if (page >= 1 && page <= (book.totalPages || 1)) {
      setCurrentPage(page);
      setGoToPage('');
    }
  }, [goToPage, book.totalPages]);

  // Обработчик клика по контейнеру
  const handleContainerClick = useCallback((event: React.MouseEvent) => {
    if (event.target === event.currentTarget) {
      setSelectedWord(null);
      setTranslation(null);
    }
  }, []);

  // Обработчик выделения текста для комментария
  const handleTextSelection = useCallback(() => {
    const selection = window.getSelection();
    if (!selection || selection.toString().trim().length === 0) return;

    const selectedText = selection.toString().trim();
    if (selectedText.length < 3) return;

    setSelectedTextForComment(selectedText);
    setIsAddCommentModalOpen(true);
  }, []);

  // Обработчик отпускания мыши
  const handleMouseUp = useCallback((event: React.MouseEvent) => {
    // Проверяем, что это не клик по слову
    const target = event.target as HTMLElement;
    if (target.tagName === 'P' || target.closest('p')) {
      return;
    }
    
    // Небольшая задержка, чтобы дать время для выделения текста
    setTimeout(() => {
      handleTextSelection();
    }, 100);
  }, [handleTextSelection]);

  // Обработчик добавления комментария
  const handleAddComment = useCallback((commentData: Omit<TextComment, 'id' | 'createdAt'>) => {
    if (!selectedTextForComment.trim()) return;

    const newComment: TextComment = {
      id: Date.now().toString(),
      bookId: book.id,
      pageNumber: currentPage,
      startIndex: 0, // Упрощенная версия - в реальности нужно найти позицию в тексте
      endIndex: selectedTextForComment.length,
      selectedText: selectedTextForComment,
      comment: commentData.comment,
      createdAt: new Date(),
      color: commentData.color
    };

    const updatedComments = [...comments, newComment];
    setComments(updatedComments);
    
    try {
      localStorage.setItem(`book-comments-${book.id}`, JSON.stringify(updatedComments));
    } catch (error) {
      console.error('Ошибка при сохранении комментариев:', error);
    }

    setSelectedTextForComment('');
    setIsAddCommentModalOpen(false);
  }, [selectedTextForComment, currentPage, book.id, comments]);

  // Обработчик удаления комментария
  const handleDeleteComment = useCallback((commentId: string) => {
    const commentToDelete = comments.find(c => c.id === commentId);
    if (!commentToDelete) return;

    const confirmDelete = window.confirm(
      `Удалить комментарий?\n\nВыделенный текст: "${commentToDelete.selectedText}"\nКомментарий: "${commentToDelete.comment}"`
    );

    if (confirmDelete) {
      const updatedComments = comments.filter(c => c.id !== commentId);
      setComments(updatedComments);
      
      try {
        localStorage.setItem(`book-comments-${book.id}`, JSON.stringify(updatedComments));
      } catch (error) {
        console.error('Ошибка при сохранении комментариев:', error);
      }
    }
  }, [comments, book.id]);

  // Обработчик клика по комментарию
  const handleCommentClick = useCallback((comment: TextComment) => {
    setCurrentPage(comment.pageNumber);
    if (!isCommentsPanelOpen) {
      setIsCommentsPanelOpen(true);
    }
  }, [isCommentsPanelOpen, setIsCommentsPanelOpen]);

  // Обработчик переключения фильтра комментариев
  const handleToggleCommentsPageFilter = useCallback(() => {
    setShowOnlyCurrentPageComments(!showOnlyCurrentPageComments);
  }, [showOnlyCurrentPageComments]);

  // Функция для получения текста текущей страницы
  const getCurrentPageText = useCallback(() => {
    if (book.pages && book.pages.length > 0 && book.pages[currentPage - 1]) {
      return book.pages[currentPage - 1];
    }
    
    const pageSize = 2000;
    const startIndex = (currentPage - 1) * pageSize;
    const endIndex = Math.min(startIndex + pageSize, book.content.length);
    return book.content.substring(startIndex, endIndex);
  }, [book, currentPage]);

  // Функция для создания текста с выделениями
  const createHighlightedText = useCallback(() => {
    const pageText = getCurrentPageText();
    const currentPageComments = comments.filter(comment => 
      comment.pageNumber === currentPage && 
      (showOnlyCurrentPageComments || isCommentsPanelOpen)
    );

    if (currentPageComments.length === 0) {
      return pageText;
    }

    // Сортируем комментарии по позиции начала
    const sortedComments = [...currentPageComments].sort((a, b) => a.startIndex - b.startIndex);
    
    let result = '';
    let lastIndex = 0;

    sortedComments.forEach(comment => {
      // Добавляем текст до комментария
      result += pageText.substring(lastIndex, comment.startIndex);
      
      // Добавляем выделенный текст
      result += `<span style="background-color: ${comment.color}; padding: 2px 4px; border-radius: 3px;">`;
      result += pageText.substring(comment.startIndex, comment.endIndex);
      result += '</span>';
      
      lastIndex = comment.endIndex;
    });

    // Добавляем оставшийся текст
    result += pageText.substring(lastIndex);
    
    return result;
  }, [getCurrentPageText, comments, currentPage, showOnlyCurrentPageComments, isCommentsPanelOpen]);

  // Функция для рендеринга обычного текста с форматированием
  const renderNormalText = useCallback((text: string) => {
    // Если текст пустой, возвращаем пустой элемент
    if (!text.trim()) {
      return <span>{text}</span>;
    }

    // Разбиваем текст на строки и обрабатываем форматирование
    const lines = text.split('\n');
    const formattedLines = lines.map((line, index) => {
      const trimmedLine = line.trim();
      
      if (!trimmedLine) {
        return <div key={index} style={{ height: '1em' }} />;
      }
      
      // Обрабатываем заголовки
      if (trimmedLine.startsWith('# ')) {
        return (
          <h1
            key={index}
            style={{
              fontFamily: formattingOptions.fontFamily,
              fontSize: '24px',
              fontWeight: 600,
              textAlign: 'center',
              margin: '2em 0 1em 0',
              color: '#1976d2',
              textTransform: 'uppercase',
              fontStyle: 'italic'
            }}
          >
            {trimmedLine.substring(2)}
          </h1>
        );
      }
      
      // Обрабатываем подзаголовки
      if (trimmedLine.startsWith('## ')) {
        return (
          <h2
            key={index}
            style={{
              fontFamily: formattingOptions.fontFamily,
              fontSize: '20px',
              fontWeight: 600,
              textAlign: 'center',
              margin: '1.5em 0 1em 0',
              color: '#333',
              fontStyle: 'italic'
            }}
          >
            {trimmedLine.substring(3)}
          </h2>
        );
      }
      
      // Обычный текст - обрабатываем абзацы
      return (
        <p
          key={index}
          onClick={handleWordClick}
          onDoubleClick={handleDoubleClick}
          style={{
            cursor: 'pointer',
            fontFamily: formattingOptions.fontFamily,
            fontSize: `${formattingOptions.fontSize}px`,
            lineHeight: '1.6',
            textAlign: 'justify',
            textIndent: '2em', // Отступ первой строки
            margin: '0 0 0.5em 0',
            whiteSpace: 'normal',
            wordBreak: 'break-word'
          }}
        >
          {trimmedLine}
        </p>
      );
    });

    return <>{formattedLines}</>;
  }, [handleWordClick, handleDoubleClick, formattingOptions]);

  // Функция для рендеринга текста
  const renderText = useCallback(() => {
    const highlightedText = createHighlightedText();
    
    if (highlightedText.includes('<span')) {
      // Если есть выделения, используем dangerouslySetInnerHTML
      return (
        <div
          dangerouslySetInnerHTML={{ __html: highlightedText }}
          onDoubleClick={handleDoubleClick}
          style={{
            cursor: 'pointer',
            display: 'block',
            width: '100%',
            whiteSpace: 'normal',
            wordBreak: 'break-word'
          }}
        />
      );
    } else {
      // Иначе рендерим обычный текст
      return renderNormalText(highlightedText);
    }
  }, [createHighlightedText, handleDoubleClick, renderNormalText]);

  // Загружаем словарь из localStorage при монтировании
  useEffect(() => {
    try {
      const savedDictionary = localStorage.getItem('userDictionary');
      if (savedDictionary) {
        const parsedDictionary = JSON.parse(savedDictionary);
        setUserDictionary(parsedDictionary);
      }
    } catch (error) {
      console.error('Ошибка при загрузке словаря:', error);
    }
  }, []);

  // Загружаем комментарии из localStorage при монтировании
  useEffect(() => {
    try {
      const savedComments = localStorage.getItem(`book-comments-${book.id}`);
      if (savedComments) {
        const parsedComments = JSON.parse(savedComments);
        setComments(parsedComments);
      }
    } catch (error) {
      console.error('Ошибка при загрузке комментариев:', error);
    }
  }, [book.id]);

  // Сохраняем текущую страницу в localStorage при изменении
  useEffect(() => {
    localStorage.setItem(`book-last-page-${book.id}`, currentPage.toString());
  }, [currentPage, book.id]);

  // Прокручиваем к началу при изменении страницы
  useEffect(() => {
    if (containerRef.current) {
      containerRef.current.scrollTop = 0;
    }
  }, [currentPage]);

  // Обновляем выделенные комментарии при изменении состояния
  useEffect(() => {
    const currentPageComments = comments.filter(comment => 
      comment.pageNumber === currentPage && 
      (showOnlyCurrentPageComments || isCommentsPanelOpen)
    );
    setHighlightedComments(currentPageComments);
  }, [comments, currentPage, showOnlyCurrentPageComments, isCommentsPanelOpen]);

  // Добавляем обработчик клика вне слова
  useEffect(() => {
    document.addEventListener('click', handleClickOutside);
    return () => {
      document.removeEventListener('click', handleClickOutside);
    };
  }, [handleClickOutside]);

  // Добавляем обработчики для изменения размера
  useEffect(() => {
    if (isResizing) {
      document.addEventListener('mousemove', handleResizeMove);
      document.addEventListener('mouseup', handleResizeEnd);
      return () => {
        document.removeEventListener('mousemove', handleResizeMove);
        document.removeEventListener('mouseup', handleResizeEnd);
      };
    }
  }, [isResizing, handleResizeMove, handleResizeEnd]);

  // Добавляем глобальный обработчик для предотвращения выделения текста при перетаскивании
  useEffect(() => {
    const preventSelection = (e: Event) => {
      if (isResizing) {
        e.preventDefault();
      }
    };
    
    document.addEventListener('selectstart', preventSelection);
    document.addEventListener('dragstart', preventSelection);
    
    return () => {
      document.removeEventListener('selectstart', preventSelection);
      document.removeEventListener('dragstart', preventSelection);
    };
  }, [isResizing]);

  // Синхронизируем containerWidth с formattingOptions при инициализации


  // Фильтруем слова для отображения в словаре
  const filteredDictionary = useMemo(() => {
    if (showOnlyCurrentPageWords) {
      return userDictionary.filter(word => word.pageNumber === currentPage);
    }
    return userDictionary;
  }, [userDictionary, showOnlyCurrentPageWords, currentPage]);

  // Фильтруем комментарии для отображения
  const filteredComments = useMemo(() => {
    if (showOnlyCurrentPageComments) {
      return comments.filter(comment => comment.pageNumber === currentPage);
    }
    return comments;
  }, [comments, showOnlyCurrentPageComments, currentPage]);

  return (
    <Box
              sx={{
          height: '100vh',
          overflow: 'visible',
          marginLeft: '80px',
          marginRight: isCommentsPanelOpen ? '320px' : 0,
          transition: 'margin-left 0.3s ease, margin-right 0.3s ease',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          padding: '20px'
        }}
      onClick={handleContainerClick}
      tabIndex={0}
      onFocus={() => {}}
      style={{ outline: 'none' }}
    >
      {/* Обертка для контейнера с иконкой ресайза */}
      <Box
        sx={{
          position: 'relative',
          width: `${containerWidth}px`,
          height: `${containerHeight}px`,
          marginLeft: '80px',
          minWidth: '150px',
          minHeight: '150px'
        }}
      >
        {/* Текст книги */}
        <Box
          ref={containerRef}
          className="container-debug text-content-container"
          data-container-name="TEXT CONTENT"
          sx={{
            overflow: 'auto',
            borderRadius: 1,
            padding: 4,
            boxShadow: 1,
            position: 'relative',
            flex: 'none',
            width: '100%',
            height: '100%',
            display: 'flex',
            flexDirection: 'column',
            backgroundColor: '#f0f8ff',
            transition: 'width 0.1s ease, height 0.1s ease'
          }}
          style={{
            border: '10px solid #0d47a1 !important'
          }}
          onMouseUp={(e) => {
            handleMouseUp(e);
            if (isResizing) {
              handleResizeEnd();
            }
          }}
        >

          


          
                <Typography
            variant="body1"
            sx={{
              fontFamily: formattingOptions.fontFamily,
              fontSize: formattingOptions.fontSize,
              lineHeight: 1.6,
              whiteSpace: 'normal',
              wordBreak: 'break-word',
              position: 'relative',
              zIndex: 1,
              display: 'block',
              width: '100%'
            }}
          >
            {renderText()}
        </Typography>

        {/* Индикатор текущей страницы с навигацией */}
        <Box
          sx={{
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            gap: 2,
            marginTop: 'auto',
            padding: 1,
            flexShrink: 0
          }}
        >
          {/* Кнопка "Предыдущая страница" */}
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              gap: 0.5,
              padding: '4px 12px',
              height: '32px',
              borderRadius: 1,
              backgroundColor: '#ffffff',
              cursor: currentPage <= 1 ? 'default' : 'pointer',
              transition: 'all 0.2s ease-in-out',
              '&:hover': {
                backgroundColor: currentPage <= 1 ? '#f5f5f5' : '#f0f0f0',
                transform: currentPage <= 1 ? 'none' : 'scale(1.05)'
              }
            }}
            style={{
              border: 'none !important'
            }}
            onClick={() => currentPage > 1 && handlePageChange(currentPage - 1)}
          >
            <IconButton
              size="small"
              disabled={currentPage <= 1}
              sx={{
                color: currentPage <= 1 ? '#bdbdbd' : '#1976d2',
                padding: 0.5,
                minWidth: 'auto',
                '&:hover': {
                  backgroundColor: 'transparent'
                }
              }}
            >
              <UpIcon fontSize="small" />
            </IconButton>
            <Typography
              variant="caption"
              sx={{
                fontFamily: 'Fira Sans, sans-serif',
                fontSize: '10px',
                color: currentPage <= 1 ? '#bdbdbd' : '#1976d2',
                fontWeight: 500
              }}
            >
              предыдущая
            </Typography>
          </Box>

          {/* Индикатор страницы */}
          <Typography
            variant="body2"
            sx={{
              fontFamily: 'Montserrat, sans-serif',
              fontWeight: 600,
              color: '#1976d2',
              padding: '4px 12px',
              backgroundColor: '#ffffff',
              borderRadius: 1
            }}
            style={{
              border: 'none !important'
            }}
          >
            Страница {currentPage} из {book.totalPages || 1}
          </Typography>

          {/* Кнопка "Следующая страница" */}
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              gap: 0.5,
              padding: '4px 12px',
              height: '32px',
              borderRadius: 1,
              backgroundColor: '#ffffff',
              cursor: currentPage >= (book.totalPages || 1) ? 'default' : 'pointer',
              transition: 'all 0.2s ease-in-out',
              '&:hover': {
                backgroundColor: currentPage >= (book.totalPages || 1) ? '#f5f5f5' : '#f0f0f0',
                transform: currentPage >= (book.totalPages || 1) ? 'none' : 'scale(1.05)'
              }
            }}
            style={{
              border: 'none !important'
            }}
            onClick={() => currentPage < (book.totalPages || 1) && handlePageChange(currentPage + 1)}
          >
            <Typography
              variant="caption"
              sx={{
                fontFamily: 'Fira Sans, sans-serif',
                fontSize: '10px',
                color: currentPage >= (book.totalPages || 1) ? '#bdbdbd' : '#1976d2',
                fontWeight: 500
              }}
            >
              следующая
            </Typography>
            <IconButton
              size="small"
              disabled={currentPage >= (book.totalPages || 1)}
              sx={{
                color: currentPage >= (book.totalPages || 1) ? '#bdbdbd' : '#1976d2',
                padding: 0.5,
                minWidth: 'auto',
                '&:hover': {
                  backgroundColor: 'transparent'
                }
              }}
            >
              <DownIcon fontSize="small" />
            </IconButton>
          </Box>
        </Box>

        </Box>
      </Box>

      {/* Тултип с переводом - рендерим вне контейнера */}
      {selectedWord && (
        <TranslationTooltip
          translation={translation}
          position={{
            x: getTooltipStyle(selectedWord.element).left,
            y: getTooltipStyle(selectedWord.element).top,
            width: getTooltipStyle(selectedWord.element).width
          }}
          isLoading={isLoading}
          onClose={() => {
            setSelectedWord(null);
            setTranslation(null);
            selectedWordRef.current = null;
          }}
        />
      )}

        {/* Элемент для изменения размера в правом нижнем углу */}
        <Box
          sx={{
            position: 'absolute',
            bottom: '-5px',
            right: '-5px',
            width: '16px',
            height: '16px',
            cursor: 'nw-resize',
            backgroundColor: 'rgba(21, 101, 192, 0.1)',
            borderRadius: '2px',
            zIndex: 1000,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            pointerEvents: 'auto',
            '&:hover': {
              backgroundColor: 'rgba(21, 101, 192, 0.2)'
            }
          }}
          onMouseDown={handleResizeStart}
        >
          <Box
            sx={{
              width: '0',
              height: '0',
              borderLeft: '4px solid transparent',
              borderRight: '4px solid transparent',
              borderTop: '4px solid #1976d2',
              transform: 'rotate(-45deg)'
            }}
          />
        </Box>
      </Box>

      {/* Панель словаря */}
      <UserDictionary
        isOpen={isDictionaryOpen}
        onClose={() => setIsDictionaryOpen(false)}
        words={filteredDictionary}
        onDeleteWord={handleDeleteFromDictionary}
        onUpdateWord={(updatedWord) => {
          const updatedDictionary = userDictionary.map(w => 
            w.id === updatedWord.id ? updatedWord : w
          );
          setUserDictionary(updatedDictionary);
          localStorage.setItem('userDictionary', JSON.stringify(updatedDictionary));
        }}
        containerHeight={0}
        currentPage={currentPage}
        showOnlyCurrentPage={showOnlyCurrentPageWords}
        onTogglePageFilter={() => setShowOnlyCurrentPageWords(!showOnlyCurrentPageWords)}
      />



      {/* Панель комментариев */}
      <CommentsPanel
        isOpen={isCommentsPanelOpen}
        onClose={() => setIsCommentsPanelOpen(false)}
        comments={filteredComments}
        onDeleteComment={handleDeleteComment}
        onCommentClick={handleCommentClick}
        showOnlyCurrentPage={showOnlyCurrentPageComments}
        onTogglePageFilter={handleToggleCommentsPageFilter}
        currentPage={currentPage}
      />

      {/* Панель навигации */}
      <NavigationPanel
        isOpen={true}
        onClose={() => {}}
        currentPage={currentPage}
        totalPages={book.totalPages || 1}
        onPageChange={(page) => handlePageChange(page)}
        formattingOptions={formattingOptions}
        onFormattingOptionsChange={(newOptions) => {
          console.log('TextReader received new formatting options:', newOptions);
          setFormattingOptions(newOptions);
        }}
      />

      {/* Модальное окно добавления комментария */}
      <AddCommentModal
        open={isAddCommentModalOpen}
        onClose={() => setIsAddCommentModalOpen(false)}
        selectedText={selectedTextForComment}
        onSave={handleAddComment}
      />
    </Box>
  );
};

export default TextReader;

