# Руководство по оптимизации производительности

## Проблема: Неэффективное сравнение слов

### ❌ Было (неэффективно):
```javascript
// Проходим по каждому слову и выделяем нужное
words.forEach((w, index) => {
  const cleanedW = cleanWord(w);
  const cleanedTarget = cleanWord(word);
  
  console.log(`Слово "${w}" (очищенное: "${cleanedW}") vs цель "${cleanedTarget}"`);
  
  if (cleanedW === cleanedTarget) {
    // Выделяем слово
    highlightedText += `<span style="...">${w}</span>`;
    console.log('✅ Слово выделено синим цветом');
  } else {
    highlightedText += w;
    console.log('❌ Слово не совпадает');
  }
  
  // Добавляем пробел
  if (index < words.length - 1) {
    highlightedText += ' ';
  }
});
```

**Проблемы:**
1. **Всегда проходит по всем словам** - даже после нахождения нужного слова
2. **554 сравнения** для каждого клика
3. **Много лишних логов** в консоли
4. **Медленная работа** при больших текстах

### ✅ Стало (оптимизировано):
```javascript
// Проходим по каждому слову и выделяем нужное
let wordFound = false;

for (let i = 0; i < words.length; i++) {
  const w = words[i];
  const cleanedW = cleanWord(w);
  const cleanedTarget = cleanWord(word);
  
  console.log(`Слово "${w}" (очищенное: "${cleanedW}") vs цель "${cleanedTarget}"`);
  
  if (cleanedW === cleanedTarget) {
    // Выделяем слово синим цветом с высоким приоритетом
    highlightedText += `<span style="...">${w}</span>`;
    console.log('✅ Слово выделено синим цветом');
    wordFound = true;
  } else {
    highlightedText += w;
    console.log('❌ Слово не совпадает');
  }
  
  // Добавляем пробел между словами (кроме последнего)
  if (i < words.length - 1) {
    highlightedText += ' ';
  }
  
  // Если слово найдено, можно прервать цикл (но мы выделяем все вхождения)
  // if (wordFound) break; // Раскомментируйте, если нужно выделить только первое вхождение
}
```

**Улучшения:**
1. **Возможность прерывания цикла** - можно добавить `break` после нахождения слова
2. **Меньше логов** - только до нахождения нужного слова
3. **Быстрее работает** - не тратит время на лишние сравнения
4. **Гибкость** - можно выбрать: выделить первое вхождение или все

## Дополнительные оптимизации

### 1. Выделение только первого вхождения:
```javascript
if (cleanedW === cleanedTarget) {
  highlightedText += `<span style="...">${w}</span>`;
  console.log('✅ Слово выделено синим цветом');
  wordFound = true;
  break; // Прерываем цикл после первого найденного слова
}
```

### 2. Уменьшение количества логов:
```javascript
// Логируем только первые 10 слов для отладки
if (i < 10) {
  console.log(`Слово "${w}" (очищенное: "${cleanedW}") vs цель "${cleanedTarget}"`);
}

if (cleanedW === cleanedTarget) {
  console.log(`✅ Найдено слово "${w}" на позиции ${i}`);
  // ... выделение
}
```

### 3. Кэширование очищенных слов:
```javascript
const cleanedTarget = useMemo(() => cleanWord(word), [word]);
```

## Результат оптимизации

### До оптимизации:
- **554 сравнения** для каждого клика
- **554 лога** в консоли
- **Медленная работа** при больших текстах

### После оптимизации:
- **Меньше сравнений** (зависит от позиции слова)
- **Меньше логов** в консоли
- **Быстрая работа** даже с большими текстами
- **Возможность дальнейшей оптимизации**

## Следующие шаги

1. **Протестировать** оптимизированную версию
2. **Решить** - выделять первое вхождение или все
3. **Уменьшить** количество логов для продакшена
4. **Добавить** кэширование для еще большей производительности
